import { MutableTextArtifact, DefaultTextArtifact } from "../artifact.ts";
import {
  contextMgr as cm,
  inflect,
  valueMgr as vm,
  serializeJS,
  denoLibPrettier as dlp,
} from "../deps.ts";
import { PersistenceHandler, PersistArtifactOptions } from "../io.ts";
import { TextArtifactNature } from "../nature.ts";
import * as code from "../code.ts";

export const typeScriptArtifact = new (class implements TextArtifactNature {
  readonly isTextArtifactNature = true;
  readonly name = "TypeScript";
  readonly defaultFileExtn: string = ".ts";
  readonly fileExtensions: string[] = [this.defaultFileExtn];
  readonly defaultPreamble: vm.TextValue =
    "// Code generated by Netspective IGS. DO NOT EDIT.\n\n";

  constructor() {}
})();

export class TypeScriptArtifact extends DefaultTextArtifact {
  constructor() {
    super({ nature: typeScriptArtifact });
  }
}

export class TypeScriptArtifacts implements code.PolyglotCodeArtifacts {
  readonly modules: TypeScriptModule[] = [];
  readonly autoFormat: boolean;

  constructor(
    readonly ph: PersistenceHandler,
    { autoFormat }: code.PolyglotCodeArtifactsOptions,
  ) {
    this.autoFormat = autoFormat !== undefined ? autoFormat : true;
  }

  declareModule(module: TypeScriptModule): void {
    this.modules.push(module);
  }

  emit(
    ctx: cm.Context,
    eh: code.PolyglotErrorHandler,
    options?: PersistArtifactOptions,
  ): void {
    for (const module of this.modules) {
      const unformattedMTA = new TypeScriptArtifact();
      let formattedMTA = unformattedMTA;
      module.emit(ctx, unformattedMTA, eh);
      if (this.autoFormat) {
        formattedMTA = new TypeScriptArtifact();
        formattedMTA.appendText(
          ctx,
          dlp.prettier.format(unformattedMTA.textFragment(ctx), {
            parser: "typescript",
            plugins: dlp.prettierPlugins,
          }),
        );
      }

      this.ph.persistTextArtifact(
        ctx,
        `${inflect.toKebabCase(module.name)}.ts`,
        formattedMTA,
        options,
      );
    }
  }
}

export class TypeScriptModule implements code.PolyglotModuleDecl {
  readonly interfaces: TypeScriptInterface[] = [];

  constructor(
    readonly code: TypeScriptArtifacts,
    readonly name: inflect.InflectableValue,
  ) {
  }

  declareInterface(intf: TypeScriptInterface): void {
    this.interfaces.push(intf);
  }

  emit(
    ctx: cm.Context,
    mta: MutableTextArtifact,
    eh: code.PolyglotErrorHandler,
  ): void {
    for (const intf of this.interfaces) {
      intf.emit(ctx, mta, eh);
    }
  }
}

export interface TypeScriptInterfaceOptions
  extends code.PolyglotInterfaceDeclOptions {
  readonly emitContentAsConst?: boolean;
  readonly emitContentAsConstIdentifier?: inflect.InflectableValue;
}

export class TypeScriptInterface implements code.PolyglotInterfaceDecl {
  readonly properties: code.PolyglotPropertyDecl[] = [];
  readonly content: object[] = [];
  readonly emitContentAsConst: boolean;
  readonly emitContentAsConstIdentifier?: inflect.InflectableValue;

  constructor(
    readonly module: TypeScriptModule,
    readonly name: inflect.InflectableValue,
    { emitContentAsConst, emitContentAsConstIdentifier }:
      TypeScriptInterfaceOptions,
  ) {
    this.emitContentAsConst = emitContentAsConst !== undefined
      ? emitContentAsConst
      : true;
    this.emitContentAsConstIdentifier = emitContentAsConstIdentifier;
  }

  declareProperty(prop: code.PolyglotPropertyDecl): void {
    this.properties.push(prop);
  }

  declareContent(content: object): void {
    this.content.push(content);
  }

  emit(
    ctx: cm.Context,
    mta: MutableTextArtifact,
    eh: code.PolyglotErrorHandler,
  ): void {
    const propDecls: string[] = [];
    for (const property of this.properties) {
      const decl = property.getInterfaceDecl(ctx, eh);
      if (decl) {
        propDecls.push(decl);
      }
    }
    const intfIdentifier = inflect.toPascalCase(this.name);
    mta.appendText(ctx, `export interface ${intfIdentifier} {\n`);
    mta.appendText(ctx, "  " + propDecls.join("\n  "));
    mta.appendText(ctx, "\n}\n\n");

    if (this.emitContentAsConst) {
      const contentConstIdentifier = this.emitContentAsConstIdentifier ||
        inflect.toCamelCase(this.name) + "Content";
      const arraySuffix = Array.isArray(this.content) ? "[]" : "";
      mta.appendText(
        ctx,
        `export const ${contentConstIdentifier}: ${intfIdentifier}${arraySuffix} = ${
          serializeJS.stringify(this.content)
        };`,
      );
    }
  }
}

export class TypicalTypeScriptProperty implements code.PolyglotPropertyDecl {
  constructor(
    readonly name: inflect.InflectableValue,
    readonly tsType: vm.TextValue,
  ) {
  }

  getInterfaceDecl(
    ctx: cm.Context,
    eh: code.PolyglotErrorHandler,
  ): string | undefined {
    return `readonly ${inflect.toCamelCase(this.name)}: ${this.tsType};`;
  }

  getContentDecl(
    ctx: cm.Context,
    content: object,
    eh: code.PolyglotErrorHandler,
  ): string | undefined {
    const value = (content as any)[this.name.inflect()];
    const identifier = inflect.toCamelCase(this.name);
    return `${identifier}: ${serializeJS.stringify(value)}`;
  }
}
